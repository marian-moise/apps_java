<RECAPITULARE:>

==================================
1.PRINCIPII OOP:
- Encapsulation - se face prin limitarea accesului la starile si comportamentele unei clase prin introducerea de modificatori de acces si de getters/setters
- Inheritance 
	- Association:
		- Agregation - cand obiectele pot functiona independent - Ex: "Sofer -> Masina";
		- Composition - cand obiectele nu pot functiona independent - Ex: "Masina -> Motor";
- Abstraction
		- Abstract Classes
		- Interfaces
- Polimirfism - proprietate care sugereaza diferite tipuri de comportament - obiecte, metode
		- static;
		- dinamic;
==================================
2.DESIGN PATTERNS:
- Singleton
- Factory
==================================
3.BAZE DE DATE:
-MySQL : Join, GroupBy, Select;
==================================
4.BIG O:
==================================
5.STACK & HEAP:
==================================
6.STRUCTURI DE DATE:
- Arrays
- Linked Lists 
	- Singly
	- Doubly
- Stacks
- Queues
- Trees
- Graphs
========================================================
7.ALGORITMI:
- SEARCH - Liniar Search - O(N);
	  - Binary Search - "Divide et impera" - O(logN);

- SORT   - Buble Sort - O(N^2);
	  - Selection Sort - O(N^2);
	  - Insertion Sort - O(N^2);


<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

CONCEPTE:

<Principiile OOP:>
- Encapsulation
- Inheritance
	- Agregation
	- Composition
- Abstraction
	- Abstract Clases
	- Interfaces
- Polimorfism

**Structuri de date:
- primitive: Integer, Long, Float, Double; Character, Boolean, Short, Byte;
- complexe: Array, Tree, Graph, Stack, Queue, LinkedList;

**Tipuri de Date:
- primitive: int, long, float, double, char, boolean, short, byte
- complexe: Integer, Long, Float, Double; Character, Boolean, Short, Byte

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

- thread 	= este un subproces din cadrul unui proces mai mare - spre ex word ul in timp ce se scrie in el ne arata si typo ul - ex de subproces
         	= java este un limbaj by default cu un singur proces si cu posibilitate de simulare de asyncronicitate prin multithreading - java suporta multithreading-ul (javascript spre ex nu);
- Overload 	= se produce atunci cand in cadrul unei clase avem mai multe functii cu acelasi nume : spre ex in cazul constructorilor multipli;
- Overflow 	= se produce atunci cand capacitatea de procesare a unei functii este depasita. Fenomenul de overflow se poate intalni cand apelam o functie recursiv si nu ii dam end case din cauza ca dupa ce se umple stack ul se arunca o eroare - StackOverflowError
		   	= se mai poate produce atunci cand capacitatea maxima a unui Integer este depasita 2 000 000 000 + 1;
- Override 	= inseamna suprascierea unei metode din cadrul unei interfete sau clase abstracte intr-o clasa copil;
- modificator de acces = reprezinta un keyword care insereaza o permisiune in cadrul unei variabile, sau functii;
	   		= pot fi publici (vizibilitate peste tot in clasa, in subclasa, in pachet, in afara pachetului), privati (doar in clasa respectiva), default, protected;
- getter setter	= sunt niste functii care restrictioneaza accesul la anumite variabile din cadrul unei clase;
			= prin intermediul getterilor se extrage "read only" o anumita proprietatte dintr o clasa;
			= prin setteri se extrage "write only" o anumita proprietate dintr o clasa;
			= geterii si setterii sunt componente ale conceptului de encapsulare;
			public int getElement() {
			return this.element;
			}

			public void setElement(int element){
			this.element = element;
			}
- constructor = este o metoda care permite instantierea obiectelor din clasa de care apartine:
			public Constructor(int element) {
			this.element = element;
			}
			= pot fi publici sau privati in functie de necesitate;
- flowul unui fisier in conceptul de git = mai intai se creea fisierul pe local, dupa care se initializeaza un repo de git in folderul ce contine fisierul respectiv, fisierul creat este astfel in faza untracked, git stie de existenta lui dar nu-l urmareste, in momentul in care se face git commit -m "mesaj" fisierul trece in faza de tracked, cand se face push dupa ce s a adaugat originea se transfera fisierele pe server;
- cum functioneaza toStringu pe clase copil si pe clase parinte = daca facem toString pe o clasa copil o sa ne returneze hashcode ul, deci va trebui sa facem un override la metoda de toString in clasa respectiva. Daca apelam metoda toString pe o clasa parinte nu ne va mai returna hashcode ul;
- Object  = este clasa este extinsa de orice alta clasa din java;
- thread pool = este o zona din memoria heap ce se ocupa cu gestionarea threadurilor;
- Int pool = este o zona din heap ce se ocupa cu gestionarea Inturilor care iau valori de la -128 ... 127 , sunt cache uite;
- String pool = este tot o zona din heap care se ocupa cu stocarea stringurilor;
- =, ==, .equals()    ------> = atribuie o anumita valoare;
                      ------> == compara referinte;
                      ------> .equals() compara continut;
- EXCEPTII:
	- sunt niste evenimente care pot aparea fie la compile-time fie la run-time;
	- sunt de 3 tipuri:
	  1.Checked Exceptions (CHECKED): ex: IOExceptions;
	  2.Runtime Exceptions (UNCHECKED): ex: NullPointerException;
	  3.Errors (UNCHECKED): ex: JVM errors;

	- avantaje:
		- propagarea exceptiilor in sus pe callstack;
		- o buna grupare si diferentiere a tipurilor de erori;
		- o buna separare a error-handling code-ului de codul normal; 

	- general:
		     = la origine ele sunt obiecte;
		     = pot fi CHECKED - cele care sunt verificate la compile time - trebuie prinse in try catch in cazul in care e posibil sa apara, altfel vom evea eroare de compilare - ex FileNotFoundException, IOException, ClassNotFoundException, etc;
		     = pot fi UNCHEKED - cele verificate la run time -> toate sunt subclase pentru RuntimeException - ex: ArrayIndexOutOfBoundsException, NullPointerException, ArithmeticException, NumberFormatException;
- Compile Time - este atunci cand prin intermediul unui compilator codul este transformat in cod masina (executabil);
- Run Time - este procesul prin care se ruleaza codul compilat;
- super()-------> este o variabila de referinta prin care se apeleaza constructorul din clasa parinte;
- super. -------> este o variabila de referinta prin care se apeleaza fielduri, variabile, metode din clasa parinte;
- this() -------> face referire la constructorul din clasa curenta;
- this.  -------> este un placeholder care face referire la un camp, variabila, metoda din clasa curenta;
- finaly -------> este un keyword care returneaza ceva default indiferent de ce returneaza try-catchul - se foloseste pentru inchiderea sesiunilor;
- 0;    --------> este o data mai mare decat -1 si mai mica decat 1 sub incidenta primitivelor de tip int sau complexelor de tip Integer;
- null  --------> este un tip caracteristic obiectelor atunci cand nu au corespondent in heap;
- testing - incercarea unei functionalitati pana aceasta cedeaza;
          - se face doar pe metode care au comporatment nu pe geteri si pe seteri;
- ce este singletonul si ce contine - este un design pattern si poate reprezenta o clasa din care se instantiaza o instanta unica;
			- contine constructorul privat;
			- contine variabila de instanta statica;
			- contine o metoda publica statica care returneaza o instanta unica;
			- avantaje: consuma putina memorie pt ca nu sunt create obiecte noi la fiecare request;
			- folosit in : setari de configurare, in logging, la driverul de database spre ex;
- ce este factory si ce contine - este un design pattern, ce poate fi o interfata sau o clasa abstracta care joaca rol de wrapper in instantierea unui anumit obiect - avantaje - decuplare, usor de extins in cod - ex de Factory - Calendar -> getInstance() - aceasta metoda utilizeaza Factory pattern;
- design pattern - este un concept ce permite rezolvarea unor probleme comune de programare prin implementarea unor solutii tipice;
- static - este un keyword care transforma o variabila din variabila de instanta in variabila de clasa - valabil si pentru metode;
- synchronized = keyword care atunci cand este pus pe o bucata de logica specifica faptul ca se permite executia unui singur thread pe rand;
- ce e StringBuilderu ce e StringBufferu - secventa de caractere - sunt alternative pentru String in varianta mutabila, StringBuileru este mai rapid dar nu este thread safe, pe cand StringBufferu este thread safe dar este mai lent;
- Runnable - este o interfata care este necesar a fi implementata de clase ale caror instante vor fi executate de un thread;
- mostenirea = proprietatea de a mosteni comportamentul claselor parinte prin implementarea de metode; pot mosteni si parametri din clasa parinte;
- composition - face referire la elemente care sunt in stransa legatura unele cu altele - ex constructorii claselor;
- agregation - face referire la elemente care sunt complet independente unele de altele - ex Angajat , Adresa - > clase independente;
- clasa - este un  blueprint care poate crea obiecte atat timp cat nu este abstracta;
		- o clasa de Java este un fisier ce contine byteCode Java care poate fi executat in JVM;
- obiect - este o instanta a unei clase; este un produs al acelei clase;
- metoda - este o functie care face ceva, afiseaza, numara, sorteaza, etc;
- scope - se refera la vizibilitatea unui element in cadrul unui bloc de cod sau in cadrul unei clase;
- heap - este o zona de memorie pe care se stocheaza obiectele;
- stack - este o zona de memorie care se ocupa cu managementul filelor de executie - locul unde se creeaza variabile, functii, etc;
- metoda void - o functie care nu returneaza nimic;
- refactorizare - este modificarea anumitor metode fara afectarea functionalitatii;
- colectie - un sir de obiecte de acelasi tip;
- JSF = Java Server Faces = framework;
- JSP = Java Server Page = este un standard de pagina web;
- API - Aplication Programming Interface;
- SQL - Strunctured Query Language
- HTML - Hiper Text Markup Language
- OOP - Object Oriented Programming
- CSS - Cascade Style Sheets
- FileReader, BufferReader, Tokenizare :
	 - FileReader este o clasa ce permite instantierea unui obiect care poate citi bytecodeul dintr-un fisier
	 - BufferReaderul este deasemenea o clasa care poate instantia un obiect care poate interpreta bytecode ul;
	 - Tokenizarea este un proces prin care se fragmenteaza anumite elemente - cand vrei sa separi doua cuvinte dupa ",";
- entry - este un ansamblu format din cheie + valoare;
- map - o structura de date ce stocheaza in mod neordonat valori atribuindu-le o cheie unica;
- tranzactie - un proces prin care se analizeaza o serie de functii iar daca cedeaza o singura functie, queryul nu se va mai executa;
- foreign key - este o coloana dintr un tabel care are corespondent in alt tabel;
- primary key - este o coloana intr un tabel pe baza careia se face legatura cu alte tabele, trebuie sa fie unica;
- select, join, group by - join - aduce in functie de join elementele din 2 sau mai multe tabele in unul singur;
						 - view - se creeaza in momentul in care se face un select - este o reprezentare vizuala a tabelului - nu este permisa editarea;
- JDBC - Java Database Conectivity = framework prin care se face conectarea la baza de date;
- BigO cate tipuri exista + ex scurte - este o modalitate de a cuantifica scalabilitatea unui program
	- On! - complexitatea cea mai mare;
	- O2^n - recursivitate - fibonacci - exponential
	- On^2 - quadratic - foarte costisitoare ca timp de executie - caracteristica sortarilor buble sort, select sort, insertion sort;
	- OnlogN - la sortare
	- On - complexitate liniara - cu bucle;
	- OlogN - binary search;
	- O(1) - the best!!;
- ce inseamna scalare - capacitatea unui algoritm de a isi mentine performanta indiferent de amploarea inputului pe care il primeste;
- ce e un logaritm - puterea la care trebuie ridicata baza pentru a putea produce un numar;
- reguli de calcul big O - worst case, drop constants, drop the nondominant, different complexity for different input (O(m + n) sau O(m * n));
- clasele wrapper - clase care convertesc primitivele in obiecte;
- garbage collectorul - este un concept din java care se ocupa cu colectarea si stergerea obiectelor de pe heap care nu au referinta catre stack;
- str de date - sunt structuri care contin date aranjate sau dezordonate;
- algoritmii - sunt mecanisme prin care se rezolva diverse probleme - spre ex de sortare, de cautare, etc;
- linked list - o strunctura de date, inlantuita in care nodurile sunt obiecte ce contin valoare si referinta catre urmatorul obiect sau catre obiectul anterior in cazul celor dublu inlantuite;
- queue - o structura de date in care insertia se face la coada iar stergerea se face de la cap - FIFO
- stack - o str de date in care atat insertia cat si stergerea se face pe ultimul element inserat - LIFO
- recursivitatea, unde se foloseste - se foloseste in cazul in care vrem sa iteram printr o str de date careia nu i stim amploarea ramificatiilor spre ex in cazul str arborescente unde poate fi nevoie de o parcurgere eficienta a arborelui - se intampla atunci cand apelam o functie in alta functie;
- tree - o str de date in care acestea sunt structurate sub forma de arbore inversat - contine un root de la care se pleaca cu inserarea datelor catre frunze;
- dinamyc programming - inseamna optimizarea anumitor programe utilizand principiul de cache uire a anumitor iteratii repetitive;
- memoization - cache-uire
- hashtable - este o str de date - in java este hash map - care stocheaza elementele in functie de o anumita cheie;
- imutabilitate - incapacitatea unui element de a-si modifica forma o data creat - spre ex Stringurile;
							= un obiect este imutabil daca nu ii mai putem modifica informatiile dar ii putem modifica referinta catre un alt obiect;
							-> ex: instantele claselor String si Integer;
- dependency injection = nu presupune folosirea keywordului "new";
- Inversion Of Control = Springul este responsabil cu instantierea obiectelor;

- final - este un non-acces modifier
		- variabilele declarate cu final pot fi initializate o singura data;
		- se aplica variabilelor, metodelor sau claselor
		- pe variabile - creeaza variabile constante
		- pe metode - impiedica suprascrierea metodei;
		- pe clase - impiedica mostenirea acelei clase de alte clase;

- declarare = alaturare de nume de variabila si tip de obiect (Ex: Rectangle rectangle); sau alaturare de nume de variabila si tip de data(Ex int counter);
- instantiere = se face prin folosirea keywordului "new" (Ex: Rectangle rectangle = new Rectangle()) - care creeaza obiectul;
- initializare = se face prin apelarea constructorului (in cazul obiectelor);
- variable = Ex: int a - "a" este variabila;
- instance variable = variabile non-statice care se regasesc la nivel de clasa; 
		class Bycicle {
			private int speed;
			private Model model;
		} 
- class variable = variabila statica care se regaseste la nivel de clasa -  va fi mereu declarata cu modificatorul static - acest lucru inseamna ca de cate ori acea clasa va fi instantiata variabila statica va avea mereu aceeasi valoare;
- in Java un obiect este creat doar prin intermediul keywordului "new". Simpla declarare a unei variabile de instanta si incercarea ei de a fi folosita in cod va produce o eroare de compilare;
- "new" - operator -> prin folosirea lui se va instantia o clasa, adica se aloca memorie pentru un nou obiect si se da referinta catre acel loc din memorie - "new" returneaza o referinta catre obiectul nou creat;
- variabile locale = acele variabile non-statice care se regasesc in interiorul metodelor;
- parametri = sunt variabile (nu sunt fielduri) si se regasesc in structura unei metode (intre parantezele "()");
- "instantiere de clasa" = "creare de obiect";
- mai multe obiecte pot avea referinte catre alte obiecte;
- obiect = este un pachet ce contine atribute care au legatura intre ele la nivel de stare si de comportament; este o abstractizare a unui obiect din viata reala;
- interfata = grup (colectie) de metode care nu au implementare;
- daca nu se implementeaza metodele unei interfete in clasa care o implementeaza va rezulata o eroare de compilare; 
- staticly-typed = java este un limbaj staticly-typed ceea ce inseamna ca pentru a folosi anumite variabile trebuie mai intai sa le declaram;
- literal = valoare constanta care poate fi data unei variabile -> Ex int x = 10 -> "10" este literalul;

<><><><><><><><><><><><><><><><><><>CLASE vs INTERFETE<><><><><><><><><><><><><><><><><><>
INTERFATA = este in principiu tot o clasa dar cu urmatoarele caracteristici:
				- variabile statice si finale;
				- nu accespta decat modificatori de acces publici - eroare de compilare daca nu sunt publici;
				- metode statice abstracte dar si statice cu implementare;
				- doar metode publice abstracte (fara implementare) si default(cu implementare dar care nu e obligatoriu sa fie suprascrise in clasele copil);
				- fara constructori - nu poate fi instantiata;
				- pot sa extinda mai multe interfete;
				- nu pot sa implementeze alte interfete;
				- metodele trebuiesc suprascrise in clasele copil;

CLASA ABSTRACTA = o clasa cu urmatoarele caracteristici:
				- variabile statice si finale;
				- metode statice abstracte dar si statice cu implementare;
				- are modificatori de acces;
				- are constrcutori default si parametrizati;
				- pot sa extinda o singura alta clasa parinte;
				- pot sa implementeze mai multe interfete;
				- poate fi invocata dar nu poate fi instantiata;
			    - metodele trebuiesc suprascrise in clasele copil;

- diferenta dintre clasa abstracta si interfata 
			= o clasa poate implementa mai multe interfete dar nu poate extinde decat o singura clasa parinte;
			= interfata nu contine modificatori de acces;
			= interfata nu contine constructor;
			= interfata poate extinde mai multe interfete (se foloseste extends Interfata_1, Interfata_2, ..., Interfata n) DAR nu poate implementa alte interfete;
			= o clasa abstracta nu poate extinde decat o alta clasa dar poate implementa mai multe alte interfete (implements Interfata_1, Interfata_2,..., Interfata_n);
			= clasa abstracta poate avea modificatori de acces privati;
			= clasa abstracta nu poate fi instantiata dar poate fi invocata - interfata nu poate fi nici instantiata nici invocata;
			= clasa abstracta poate avea constructor default sau parametrizat - interfata nu are conceptul de constructor;

- asemanari intre clasa abstracta si interfata
		    = o interfata poate extinde o alta interfata sau chiar mai multe;
			= o clasa poate extinde o singura alta clasa;
			= nu se pot instantia obiecte din ele;
			= metodele trebuie sa fie suprascrise in clasele copil pentru a putea fi utilizate;
			= ambele pot contine variabile statice sau finale;
			= ambele pot furniza implementare de metode statice;
= o interfata poate sa extinda o singura clasa abstracta (ex interface List extends Collection);
= o clasa abstracta poate sa extinda o clasa abstracta si sa implementeze in acelasi timp o interfata;
= in java HashMap nu face parte din Collection ci din Map;

===========================================================<POLIMORFISM>=============================================================================											   
- Polimorfismul se poate realiza atat cu clase abstracte cat si cu interfete;

- Exemplu POLIMORFISM : se creaza o interfata LimbiStraine; LimbiStraine are o metoda "vorbeste()"; Putem crea o clasa "Astronaut" care sa implementeze interfata LimbiStraine, facandu-se override la metoda vorbeste() pentru a returna "Vorbeste limba franceza". Se mai poate crea deasemenea o alta clasa "Inginer" care sa implementeze interfata LimbiStraine iar metoda vorbeste() sa se suprascrie si sa aiba returnul "Vorbeste limba germana".

- Caracterul polimorfic se refera la metodele implementate si anume la faptul ca o anumita metoda poate returna rezultte diferite in functie de implementare;

- Exista 2 tipuri de polimorfism:
	1. static : se realizeaza prin overloading : in interfata LimbiStraine avem o metoda vorbeste() -> "Vorbeste limba germana" si o alta metoda vorbeste() -> "Vorbeste limba germana de : " + years; In Inginer putem implementa vorbeste() -> "Vorbeste limba germana" dupa care se poate implementa si vorbeste() -> "Vorbeste limba germana de : " + years;
	2.dinamic : cazul exemplificat mai sus cu Inginer si Astronaut -> cu metoda vorbeste();

==============================================================================================================================================================	

<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>SQL<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
- tipurile de join :

	SELECT column FROM tableA
	INNER JOIN tableB ON tableA.key = tableB.key;
	-> face join pe toate elementele din A si B care au cheie comuna;

	SELECT column FROM tableA
	LEFT JOIN tableB ON tableA.key = tableB.key;
	-> face join pe toate elementele din A indiferent daca au sau nu cheie comuna - in dreapta unde nu sunt elemente se autocompleteaza cu null;

	SELECT column FROM tableA
	LEFT JOIN tableB ON tableA.key = tableB.key
	WHERE tableB.key IS NULL;
	-> face join pe toate elementele din tabela A care au cheia din B nula

	SELECT column FROM tableA
	RIGHT JOIN tableB ON tableA.key = tableB.key;
	-> face join pe toate elementele din B indiferent daca au corespondent sau nu in A - in stanga unde nu sunt elemente se autocompleteaza cu null;

	SELECT column FROM tableA
	RIGHT JOIN tableB ON tableA.key = tableB.key
	WHERE tableA.key IS NULL;
	-> face join pe toate elementele din B care au cheia din A nula;


	SELECT column FROM tableA
	FULL OUTER JOIN tableB ON tableA.key = tableB.key;
	-> face join pe toate elementele;

	SELECT column FROM tableA
	FULL INNER JOIN tableB ON tablea.key = tableB.key;
	-> face join pe elementele care au cheie nula din ambele parti;

- scrie functiile pentru urmatoarele actiuni :
	- sterge baza de date - DROP DATABASE
	- sterge un tabel - DROP TABLE
	- creeaza un tabel nou - CREATE TABLE
	- sterge datele din tabel - TRUNCATE TABLE
	- adauga o coloana y la tabelul x - ALTER TABLE x ADD y
	- sterge o coloana y din tabelul x - ALTER TABLE x DROP COLUMN y


<>ALGORITMI<>:<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

- inversare int;

x = 1234;

public int reverseInt(int num){
	
	unit = 1234 % 10 = 4  rev = 0 * 10 + 4 = 4 num = num /10;
	unit = 123 % 10 = 3 rev = 4 * 10 + 3 num = num /10
	unit = 12 % 10 = 2 rev = 43 * 10 + 2 num = num /10
	unit = 1 % 10 = 1 rev = 432 * 10 + 1 ;

	while (num % 10 >= 1) {
		int unit = num % 10;
		int rev = unit * 10 + unit;
		num / 10;
	}

	return rev;
}


- inversare a doua nr folosind doar operatii;

        a = 2;
        b = 3;
        a = a + b;
        b = a - b;
        a = a - b;

- fibonacci iterativ + complexitati - O(n)

       int[0] = 0;
       int[1] = 1;
       for(int i = 2; i < num; i++){
       	arr[i] = arr[i - 2] + arr [i - 1];
       }

- un alg de sortare + complexitati - select sort -> O(n^2);

public void selectSort(int[] nums) {
	for(int i = 0; i < nums.length; i++) {
		for(int j = i + 1; j < nums.lenght; j++) {
			if (arr[i] > arr[j]) {
			int temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
			}
		}
	}
}


- 2 algoritmi de cautare cu complexitati din ce in ce mai bune:

- cautare liniara - O(n);

public boolean liniarSearch(int[] nums, int x) {
	for(int i = 0; i <= nums.length; i++) {
		if (nums[i] == x) {
		 return true;
		}
	}
	return false;
}

- cautare binara - O(logN);

public boolean binarySearch(int[] nums, int x) {
	int left = 0;
	int right = nums.length - 1;

		while (left <= right) {
		int mid = (right - left)/2;

		if (x == nums[mid]){
			 return true;
			} else if (x < nums[mid]) {
			 right = mid - 1;
			} else {
			 left = mid + 1;
			}
		}

	return false;
}

================================================================================================================================================

JDK 1.5 (adica JAVA 5) -> Java Enum, Generics, autoboxing, unboxing and varargs

================================================================================================================================================

Stages of running a java app:
1.se creaza fisierul .java in care se scriu instructiunile programului;
2.javac HelloWorld.class -> se compileaza fisierul .java -> prin invocarea compilatorului de java se va compila fisierul.java, adica se va transforma intr-un fisier .class care contine bytecode-ul fisierului anterior;
3.java HelloWorld -> se ruleaza programul de catre JVM -> intervine interpretatorul din JVM care interpreteaza bytecode-ul din fisierul .class - pentru a putea fi executat de JVM;
4. se afiseaza outpul-ul;

JDK - bundle care inglobeaaza JRE (care inglobeaza JVM)
JRE - creaza o instanta a JVM-ului care executa codul (Java Runtime);
JVM - este o aplicatie care proceseaza fisierele .class si returneaza un output(Java Virtual Machine)

================================================================================================================================================

Avntaje SpringBoot (fata de Spring MVC):
- acces mai facil la dependinte;
- embedded servlet container = Tomcat server; 

Exemple de design patterns folosite in proiecte:
SessionFactory - Factory design pattern;
open db session - Singleton - nu este nevoie sa instantiem de fiecare data conexiunea la baza de date;

- pentru o singura db se va instantia o singura SessionFactory
- pentru mai multe conexiuni la db este necesara instantierea a mai multor SessionFactorys;

- Hibernate extinde JPA (care e furnizata de ORACLE)
- persistance context - cand se deschide o sesiune se aloca o zona de memorie in care se stocheaza toate starile unui anumit obiect si in plus mai exista si un obiect care asigura conectarea la baza de date;

- transient = stare in care se afla un obiect nou creat dar care nu este inca managed de persistance context (adica care inca nu a fost salvat in db); Ex: Object o = new Object(); 
- persistent = stare in care se afla un obiect care a fost manage uit de persistance context - adica care a fost salvat spre ex. session.save(o);
- detached = stare in care este un obiect atunci cand se inchide sesiunea;
- HikaryPool - este un connection pool folosit by default de catre spring boot;

================================================================================================================================================

Anotari in Spring:
@Component - aceasta anotare se regaseste pe clasele care ar trebui tratate de Spring ca si Bean-uri;

@Autowired - este folosit pentru a identifica si a injecta un tip de Bean;

Dependency Injection = este un design pattern - practic se refera la faptul ca instantierea unui obiect se face prin "injectarea" obiectului respectiv, fara a mai folosi keywordul "new";

IOC = Spring framework se ocupa de instantierea obiectelor;

@SpringBootApplication = contine instructiunile de initializare a aplicatiei de spring boot - nitializeaza contextul de spring;

@EnableAutoConfiguration = Spring Boot looks for auto-configuration beans on its classpath and automatically applies them 

@Bean = annotations are used at the method level and indicate that a method produces a bean that is to be managed by Spring container

@Service = It is used at the class level. It shows that the annotated class is a service class, such as business basic logic, and call external APIs

@Repository = It is a Data Access Object (DAO) that accesses the database directly. It indicates that the annotated class is a repository. 

@Configuration = It is used as a source of bean definitions. It is a class-level annotation.

@Controller = The annotation is used to indicate that the class is a web request handler. It is often used to present web pages. It is most commonly used with @RequestMapping annotation. 

@RequestMapping = is used to map the HTTP request. It is used with the class as well as the method. It has many other optional elements like consumes, name, method, request, path, etc.

================================================================================================================================================

HASH TABLE internals:

- pentru a folosi hashTable cu obiecte custom ca si key aceste obiecte trebuie sa fie IMUTABILE = sa nu mai poata fi modificate dupa initializare
acest lucru realizandu-se prin :
		- clasa din care se instantiaza obiectele trebuie sa fie finala (sa nu mai poata fi extinsa de alte clase copil)
		- filedurile acelei clase si metodele trebuie sa fie finale (fieldurile constante, iar metodele sa nu mai poata fi suprascrise)
		- sa nu existe setteri;
		- daca exista referinte catre alte obiecte si acele obiecte trebuie sa fie imutabile;

- o alta conditie mandatory este sa se respecte contractul equals-hashCode = in clasa din care se va instantia obiectul este obligatoriu sa se suprascrie metodele equals() si hashCode() din clasa Object. 

Ex: daca instantiem doua obiecte Client care au aceeasi proprietati putem avea urmatoarele situatii:
	1. daca nu avem suprascrise equals() si hashCode() -> se vor introduce in map doua intrari desi este acelasi obiect;
	2. daca avem suprascris equals() dar nu avem suprascris si hashCode() - se vor introduce in map doua intrari desi este acelasi obiect;
	3. daca avem suprascris doar hashCode() - se vor introduce in map doua obiecte desi hashCode-ul este acelasi;
	4. daca avem suprascrise atat equals() cat si hashCode() - se va introduce in map un singur element in cazul in care elementele sunt egale;

Contract equals-hashCode = spunem ca doua obiecte sunt egale cu equals() daca ambele obiecte au acelasi hashCode -> metoda de hasCode() va returna mereu acelasi hashCode pentru acelasi input - daca se modifica cat de putin inputul metoda va returna un hashCode diferit;

- daca nu sunt imutabile in momentul in care modificam obiectul care este deja in map si incercam sa il extragem vom obtine NULL - pentru ca in momentul in care facem map.get(key) se recalculeaza hash-ul, se regenereaza indexul se duce pe index catre bucket-ul din hashtable si se uita la hashcode, daca este egal se uita la valoare cu equals -> intrucat valoarea nu mai este egala cu valoarea care s-a mapat initial => NULL;

Este posibil sa avem doua obiecte diferite dar care au acelasi hashCode?
R: Da, aceasta este cauza coliziunilor din hashTables;

Este posibil ca doua obiecte egale sa aiba hashCode diferit?
R: Nu, acest lucru incalca contractul equals-hashCode;

De ce este nevoie sa suprascrii si hashCode daca suprascrii equals in Java?
R: Este necesar intrucat structurile de date de tip hashTable depind de contractul equals-hashCode;

================================================================================================================================================

java este pass-by-value -> adica intr-o metoda daca punem la parametru un obiect inseamna ca ii punem valoarea adresei de memorie a acelui obuect - adica ii facem o copie la valoarea adresei de memoire a acelui abiect, si spunem ca obiectul respectiv pointeaza catre o copie a valorii adresei de memorie!!!!

Does Java "pass-by-reference" or "pass-by-value" when passing arguments to methods?
It seems like a simple question (it is), but many people get it wrong by saying:
Objects are passed by reference and primitive types are passed by value.
A correct statement would be:
Object references are passed by value, as are primitive types. Thus, Java passes by value, not by reference, in all cases.

================================================================================================================================================

Difference between Composition, Aggregation and Association in OOP?
If two objects are related to each other, they are said to be associated with each other. Composition and Aggregation are two forms of association in object-oriented programming. The composition is stronger association than Aggregation. In Composition, one object is OWNER of another object while in Aggregation one object is just USER of another object. If an object A is composed of object B then B doesn't exist if A ceased to exists, but if object A is just an aggregation of object B then B can exists even if A ceased to exist.

================================================================================================================================================

Difference between Composition and Inheritance:
The main difference between Composition and Inheritance in Java is that Composition allows reuse of code without extending it but for Inheritance, you must extend the class for any reuse of code or functionality.

================================================================================================================================================

Now back to primary questions “What is Enum in java” simple answer Enum is a keyword in java and in more detail term Java Enum is a type like class and interface and can be used to define a set of Enum constants. 

Enum constants are implicitly static and final and you can not change their value once created. Enum in Java provides type-safety and can be used inside switch statements like int variables. 

================================================================================================================================================

Generic in Java is added to provide compile-time type-safety of code and removing the risk of ClassCastException at runtime which was a quite frequent error in Java code, for those who doesn’t know what is type-safety at compile-time, it’s just a check by the compiler that correct Type is used in the correct place and there should not be any ClassCastException.

================================================================================================================================================

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